
\documentclass{agregfiche}

% V1 par Charlie Jacomme
% Relu avec Thomas Chatain

\title{Leçon 901 - Structures de données. Exemples et applications.}

\begin{document}
\maketitle

\secrapports
\begin{rapport}{2018}
	Le mot algorithme ne figure pas dans l’intitulé de cette leçon, même si l’utilisation des structures de
	données est évidemment fortement liée à des questions algorithmiques. La leçon doit donc être orientée
	plutôt sur la question du choix d’une structure de données. Le jury attend du candidat qu’il présente
	différents types abstraits de structures de données en donnant quelques exemples de leur usage avant de
	s’intéresser au choix de la structure concrète. Le candidat ne peut se limiter à des structures linéaires
	simples comme des tableaux ou des listes, mais doit présenter également quelques structures plus
	complexes, reposant par exemple sur des implantations à l’aide d’arbres. Les notions de complexité des
	opérations usuelles sur la structure de données sont bien sûr essentielles dans cette leçon.
\end{rapport}

\secindispensables

\begin{itemize}
	\item  Types abstraits et implantations concrètes.
    \item Structures linéaires et non linéaires. Exemples de structures complexes.
	\item Complexité des opérations usuelles selon implantation.
\end{itemize}

\secasavoir

\begin{itemize}
	\item  Tableaux, listes, piles, files, files de priorité, arbres, graphes (orientés et non orientés), ensembles, dictionnaires.
    \item Influence de la structure de données sur un algorithme choisi.
    \item Pour un même type de données (e.g un graphe), exemples de choix de représentations optimisés selon l'ensemble de données possibles (e.g graphe sparse ou dense)
	\item Notion de coût amorti.
    \item Connaître au moins une structure complexe (tas, union-find, arbres approximativement équilibrés,\dots)
	
\end{itemize}

\secidees

\begin{itemize}
	\item Tas de Fibonacci.
	\item Représentation des graphes.
    	\item Notion de types persistants et mutables.
\end{itemize}

\secpieges

\begin{itemize}
	\item Les algorithmes ne doivent pas être le c\oe ur de la leçon, mais bien les structures de données.
	\item Les dessins sont souvent très appropriés pour représenter des structures de données et leurs évolutions.
   	\item Attention à ne pas s'éparpiller avec trop de structures différentes et à faire un catalogue. Il n'est pas forcément nécéssaire d'écrire toutes les interfaces des types abstraits.
	\item Bien avoir en tête les abstractions. Par exemple, un dictionnaire ne porte pas nécéssairement sur des strings.
	\item La complexité, c'est bien, la comparaison des complexités, c'est mieux.
	\item Ne pas être trop lié à un langage de programmation.
	\item Les structures avancées introduites doivent être accompagnées d'une application.
\end{itemize}

\secquestionsclassiques

\begin{itemize}
	\item Pourquoi avoir une approche par types abstraits ?
%    les aglorithmes construits au niveau supérieur sont indépendant 
%de l'implémentation de ce en dessous. Modularité.
	\item Quelles structures de données sont en pratique les plus 
	utilisées, et intégrées nativement dans les languages de 
	programmations ?
%    les listes et les dictionnaires
	\item Connaissez vous l'implémentation des [insérer ici une 
	structure] utilisée en pratique ?
%    dictionnaire via table de hachage
	\item Avec les listes chaînées/doublement chaînées, quelles 
	opérations sont plus ou moins complexes ?
%    concaténation, suppresion des
	\item Le choix du type, par exemple persistant et mutable, est souvent lié à des soucis d'efficacité. Y a-t-il d'autres préoccupations lors de la programmation influencées par ce choix ?
    \item Questions techniques/point de détail sur l'une des structures présentées.
\end{itemize}

\secreferences

\begin{itemize}
\item \input{refs/cormen}
\item \input{refs/beauquier}
\end{itemize}

\secdev

\begin{itemize}
\item \input{dev/tri_tas}
\item \input{dev/hachageparfait}
\item \input{dev/abroptimaux}
\end{itemize}


\end{document}
